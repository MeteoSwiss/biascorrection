% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/qqmap_int.R
\name{qqmap_int}
\alias{qqmap_int}
\title{Quantile mapping}
\usage{
qqmap_int(fcst, obs, fcst.out = fcst, span = min(1, 31/nrow(fcst)),
  anomalies = TRUE, multiplicative = FALSE, nn = 7, ...)
}
\arguments{
\item{fcst}{n x m x k array of n lead times, m forecasts, of k ensemble
members}

\item{obs}{n x m matrix of veryfing observations}

\item{fcst.out}{array of forecast values to which bias correction should be
applied (defaults to \code{fcst})}

\item{span}{the parameter which controls the degree of smoothing (see \code{\link{loess}})}

\item{anomalies}{logical, should quantile mapping be applied to forecast and
observed anomalies (from forecast ensemble mean) only?}

\item{multiplicative}{logical, is quantile correction to be applied
multiplicatively?}

\item{nn}{number of lead times to be included around the lead time to be
calibrated (i.e. \code{ceiling((nn - 1)/2)} before and \code{floor((nn -
1)/2)} after). The interval to estimate quantile corrections is held
constant, that is, the first \code{nn} lead times are used to estimate the
quantile correction for lead time one. The default is to lump all lead times
together \code{nn = nrow(fcst)}.}

\item{...}{additional arguments for compatibility with other bias correction
 methods}
}
\description{
Computes bias correction with quantile mapping
}
\details{
The quantile mapping algorithm estimates quantile correction factors
 for \code{n} quantiles. For each forecast value in \code{fcst.out}, the
 percentile within which the value falls in the distribution of input
 forecasts \code{fcst} is determined and the corresponding quantile
 correction applied. For multiplicative quantile mapping
 (\code{multiplicative = TRUE}), the bias corrected forecast
 (\code{fcst.out}) is divided by the ratio of forecast to observed quantiles,
 whereas for additive quantile mapping \code{multiplicative = FALSE}, the
 difference between the forecast and observed quantiles are subtracted from
 \code{fcst.out}. The quantiles are estimated for at least 50 discrete values
 from the 5th to 95th percentile, or, if there are enough observations for
 \code{n = n_obs / 10} discrete quantiles excluding the 5 smallest and
 largest values. If \code{anomalies} is set, forecast and observed anomalies
 are computed with reference to the forecast ensemble mean (the signal) and
 the quantile mapping is only applied to the anomalies with the signal being
 left uncorrected.

 The quantile mapping is lead time dependent, parameter \code{nn} is used to
 select the number of lead times on either side of the lead time that is to
 be corrected to be included in the quantile estimation. For the beginning
 and end of the series, the lead-time interval is kept constant, so that to
 estimate the quantile correction for the first lead time, the first
 \code{nn} lead times are used. If \code{exact = FALSE}, the lead time
 dependent quantiles for the forecast are directly estimated from single lead
 times without the surrounding \code{2*nn} lead times. This is a quick and
 dirty fix to speed up processing.
}
\examples{
## initialise forcast observation pairs
nens <- 51
signal <- outer(sin(seq(0,4,length=215)), sort(rnorm(30, sd=0.2)), '+')
fcst <- array(rnorm(length(signal)*nens, sd=seq(2,4,length=215)), c(dim(signal), nens)) + c(signal)
obs <- array(rgamma(length(signal), shape=2), dim(signal)) +
  signal
fcst.debias <- biascorrection:::qqmap_int(fcst[,1:20,],
  obs[,1:20], fcst.out=fcst[,21:30,])
oprob <- (seq(obs[,21:30]) - 1/3) / (length(obs[,21:30]) + 1/3)
plot(quantile(obs[,21:30], type=8, oprob),
  quantile(fcst[,21:30,], type=8, oprob),
  type='l', lwd=2, xlab='Observed quantiles',
  ylab='Forecast quantiles',
  main='Out-of-sample validation for qqmap_int')
abline(c(0,1), lwd=2, lty=2)
lines(quantile(obs[,21:30], type=8, oprob),
  quantile(fcst.debias, type=8, oprob), lwd=2, col=2)
minprob <- min((6 - 1/3) / (nrow(obs)*20 + 1/3), 0.05)
## oqlim <- apply(apply(obs[,1:20], 1, quantile, type=8, prob=c(minprob, 1- minprob)), 1, median)
oqlim <- quantile(obs[,1:20], type=8, prob=c(minprob, 1-minprob))
abline(v=oqlim, lwd=2, lty=3)
text(oqlim[2] + 0.1, par('usr')[3] + 0.5,
  'Extrapolated\\ncorrection', adj=c(0,0), cex=0.67)
text(oqlim[2] - 0.1, par('usr')[3] + 0.5,
  'Explicit quantile\\ncorrection', adj=c(1,0), cex=0.67)
legend('topleft', c('No bias correction', 'qqmap_int'), lwd=2, col=1:2, inset=0.05)
}
\keyword{util}

